QUIZ 1 Study Guide
Command	What It Does	How to Use It
git init	Initializes a new Git repository in the current folder	git init
git add	Stages file(s) to be included in the next commit	git add file.txt or git add . (adds all changes)
git commit	Saves the staged changes to your local repository	git commit -m "Your message here"
git status	Shows current status of the working directory and staging area	git status
git checkout	Switches to a different branch or commit	git checkout branch-name
git checkout -b new-branch (create + switch)
git branch	Lists, creates, or deletes branches	git branch (list)
git branch new-branch (create)
git clone	Copies an entire remote repository to your local machine	git clone https://github.com/user/repo.git
git push	Uploads local commits to the remote repository	git push origin branch-name
git pull	Fetches and merges changes from the remote repository into your current branch	git pull origin branch-name
git merge	Combines changes from another branch into your current branch	git merge branch-name


Purpose: To create constants whose values cannot be changed once assigned.​
Training Hub
+5
GeeksforGeeks
+5
Learn R, Python & Data Science Online
+5

Usage:

java
Copy code
final int MAX_VALUE = 100;
Behavior:

Once a final variable is assigned a value, it cannot be reassigned.

For object references, the reference cannot point to a different object, but the object's internal state can still be modified.​

Blank Final Variables:

A final variable declared without an initial value must be initialized in the constructor.​

🔹 Final Methods
Purpose: To prevent method overriding in subclasses, ensuring consistent behavior.​

Usage:

java
Copy code
public final void display() {
    // method implementation
}
Behavior:

A final method cannot be overridden by subclasses.

This helps maintain the intended functionality of the method.​

🔹 Final Classes
Purpose: To prevent a class from being subclassed, enhancing security and design stability.​

Usage:

java
Copy code
public final class UtilityClass {
    // class implementation
}
Behavior:

A final class cannot be extended by other classes.

This is commonly used in core Java classes like String and Integer.​

🔸 Additional Notes
Static Final Variables:

Often used to define constants that are shared across all instances of a class.​

Final Reference Variables:

While the reference cannot point to a new object, the object's internal state can still be changed.





 1. OO_principles.pdf – Object-Oriented (OO) Principles and Basics
This document lists fundamental principles and concepts of object-oriented design:

OO Principles:
Encapsulate what varies – isolate changes in behavior or data.

Favor composition over inheritance – use "has-a" over "is-a" relationships.

Program to an interface, not an implementation – rely on abstract types.

Strive for loosely coupled designs – minimize interdependencies.

Open for extension, closed for modification – support adding features without changing existing code.

Depend on abstractions, not concrete classes – reduces dependency on specific implementations.

Only talk to your friends – follow the Law of Demeter, avoid excessive object interaction.

Don’t call us, we’ll call you – use inversion of control, such as callbacks or dependency injection.

Single Responsibility Principle – each class should have only one reason to change.

OO Basics:
Abstraction

Encapsulation

Polymorphism

Inheritance

📙 2. OOA_D.pdf – Object-Oriented Analysis & Design (OOA&D)
This is a conceptual and practical introduction to object-oriented analysis and design, contrasting it with functional decomposition.

Key Takeaways:
Functional Decomposition Issues: Leads to tightly coupled and weakly cohesive systems, making changes harder and error-prone.

OOA&D Benefits: Designs are easier to change, test, and understand. Objects take responsibility, reducing reliance on central control.

Transition from Functional to OO: Objects encapsulate behavior and data. Responsibilities are distributed.

Terminology & Perspectives:

Conceptual: Object responsibilities.

Specification: Interfaces and behaviors.

Implementation: Code and data.

OO Concepts Revisited:

Polymorphism: Same interface, different behaviors.

Abstract Classes: Define common structure/behavior for subclasses.

Cohesion and Coupling: Aim for high cohesion and low coupling for maintainable systems.

📗 3. SoftwareLifeCycle.pdf – Software Development Life Cycle (SDLC)
Outlines the main phases of software development with brief descriptions:

Phases:
Analysis – Determine if software is needed and feasible.

Requirements & Specifications – Define what the system should do and how.

Design – Plan the solution using models like UML, pseudocode.

Implementation – Code the system.

Testing & Debugging – Validate and verify the code works as intended.

Documentation – For developers, users, and administrators.

Deployment – Install and configure the system on target platforms.

Training – Educate users and administrators.

Maintenance – Fix bugs, add improvements, apply security patches.

Retirement – Decommission the system when it’s no longer needed.

Here’s a detailed summary of the key points on **User Stories and Iteration Planning**:

### **User Stories**
- Informal descriptions of software features, written from a user’s perspective.
- Typically recorded on index cards, Post-it notes, or project management tools.
- Written by various stakeholders including users, clients, managers, or developers.

### **Principles**
- Created to shape system functionality based on user needs.
- Often written by product managers (or product owners in Scrum), but any team member can contribute.

### **Common Templates**
1. *As a \<role>, I can \<capability>, so that \<benefit>*
2. *In order to \<benefit> as a \<role>, I can \<goal/desire>*
3. *As \<who> \<when> \<where>, I \<want> because \<why>*

### **Examples**
- **Screening Quiz:** *As an HR manager, I want to create a screening quiz to evaluate potential recruits.*
- **Quiz Recall:** *As a manager, I want to browse existing quizzes to determine if updates or reuse are possible.*
- **Limited Backup:** *As a user, I can exclude folders from backups to avoid unnecessary storage use.*

### **Acceptance Criteria**
- Define conditions that must be met for a story to be considered complete.
- Ensure all requirements are satisfied before a feature is accepted.

### **Relationship to Epics, Themes, and Initiatives**
- **Epic:** Large user stories or closely related groups of stories.
- **Initiative:** A collection of epics or stories structured hierarchically.
- **Theme:** Stories grouped by a common theme or relationship.

### **Iteration Planning with User Stories**
#### Assigning Points:
- Stories are assigned points based on difficulty.
- Small projects may use simple scales (e.g., 1, 2, 3).
- Larger projects often use Fibonacci sequences or powers of 2 for estimation.
- Higher points indicate more complexity or time required.

#### Selecting Stories for Iteration:
1. Estimate total points the team can complete in an iteration.
2. Prioritize stories with stakeholders.
3. Ensure dependencies are accounted for.
4. Select stories so the total points match the estimated team capacity.

#### Subsequent Iteration Planning:
- Completed story points determine **velocity**.
- Teams can adjust workload dynamically (e.g., adding stories if completed early or refining work).
- Future iteration estimates improve with experience.

### **Adding New User Stories**
- New stories emerge during development as needs evolve.
- Any team member can propose a new user story.
- Some stories may be discarded as project understanding improves.
- Iteration planning includes reviewing existing stories and introducing new ones.

This structured approach ensures efficient iteration planning while maintaining flexibility. Let me know if you need further clarification!

1. Encapsulation
Definition: Hiding internal state and requiring all interaction to be performed through an object’s methods.

Why it's useful: It protects an object's data and ensures controlled access.

Example: Using private fields and public getters/setters in a Java class.

1. Encapsulation
Definition: Hiding internal state and requiring all interaction to be performed through an object’s methods.

Why it's useful: It protects an object's data and ensures controlled access.

Example: Using private fields and public getters/setters in a Java class.



1. Encapsulation
Definition: Hiding internal state and requiring all interaction to be performed through an object’s methods.

Why it's useful: It protects an object's data and ensures controlled access.

Example: Using private fields and public getters/setters in a Java class.

2. Abstraction
Definition: Hiding complex implementation details and showing only essential features of an object.

Why it's useful: It simplifies the interface and reduces complexity.

Example: An abstract class or interface lets you define what needs to be done, not how.

3. Inheritance
Definition: One class (child/subclass) inherits the properties and behavior of another class (parent/superclass).

Why it's useful: Promotes code reuse and establishes a relationship between types.

Example:

4. Polymorphism
Definition: The ability of a single function, class, or interface to work in different ways depending on the context.

Why it's useful: Enables you to write flexible and extensible code.

Types:

Compile-time (method overloading)

Run-time (method overriding via inheritance)

Definition: A design principle where one class contains another class as a member instead of inheriting from it.

"Has-a" relationship: Unlike inheritance's "is-a", composition models "has-a".

Why it's often better than inheritance: It’s more flexible, avoids tight coupling, and allows for behavior changes at runtime.

In software engineering, use cases are a fundamental tool used during requirements analysis to describe how a system will interact with external entities (like users or other systems). Here's a breakdown of use cases, including both diagrams and descriptions:

📌 What is a Use Case?
A use case describes a specific way a user (called an actor) interacts with a system to achieve a goal.

👥 Use Case Elements:
Actor: A user or external system that interacts with the software.

System: The software/application being developed.

Use Case: A specific function or behavior the system provides to the actor.

🖼️ Use Case Diagram (UML)
A Use Case Diagram is a visual representation using UML (Unified Modeling Language).

Key components:
Stick figure: Represents an actor.

Oval/ellipse: Represents a use case (a system function).

Rectangle/box: Represents the system boundary.

Lines: Show interactions (actor ↔ use case).

